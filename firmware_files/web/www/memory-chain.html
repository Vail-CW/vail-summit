<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Memory Chain - VAIL SUMMIT</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Arial, sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            color: #fff;
            padding: 20px;
            min-height: 100vh;
        }
        .container { max-width: 900px; margin: 0 auto; }
        header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            background: rgba(255,255,255,0.1);
            border-radius: 15px;
            backdrop-filter: blur(10px);
        }
        h1 { font-size: 2rem; margin-bottom: 10px; }
        .status-bar {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 15px;
            flex-wrap: wrap;
        }
        .status-item {
            background: rgba(255,255,255,0.15);
            padding: 8px 16px;
            border-radius: 8px;
            font-size: 0.9rem;
        }
        .status-connected { color: #4ade80; }
        .status-disconnected { color: #f87171; }
        .game-container {
            background: rgba(255,255,255,0.1);
            border-radius: 15px;
            padding: 30px;
            backdrop-filter: blur(10px);
            margin-bottom: 20px;
        }
        .game-state {
            text-align: center;
            margin-bottom: 30px;
        }
        .game-state h2 {
            font-size: 2.5rem;
            margin-bottom: 10px;
        }
        .state-ready { color: #60a5fa; }
        .state-playing { color: #fbbf24; }
        .state-listening { color: #4ade80; }
        .state-correct { color: #10b981; }
        .state-wrong { color: #ef4444; }
        .game-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-bottom: 30px;
        }
        .stat-card {
            background: rgba(255,255,255,0.1);
            padding: 20px;
            border-radius: 10px;
            text-align: center;
        }
        .stat-value {
            font-size: 2.5rem;
            font-weight: bold;
            margin-bottom: 5px;
        }
        .stat-label {
            font-size: 0.9rem;
            opacity: 0.8;
        }
        .sequence-display {
            background: rgba(0,0,0,0.3);
            border-radius: 10px;
            padding: 25px;
            text-align: center;
            min-height: 100px;
            margin-bottom: 25px;
            font-size: 2rem;
            font-family: monospace;
            letter-spacing: 8px;
        }
        .controls {
            display: flex;
            gap: 15px;
            justify-content: center;
            flex-wrap: wrap;
        }
        button {
            padding: 15px 30px;
            font-size: 1.1rem;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.2s;
        }
        .btn-primary {
            background: #00d4ff;
            color: #1e3c72;
        }
        .btn-primary:hover { background: #00b8e6; }
        .btn-secondary {
            background: rgba(255,255,255,0.2);
            color: #fff;
        }
        .btn-secondary:hover { background: rgba(255,255,255,0.3); }
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .settings-panel {
            background: rgba(255,255,255,0.1);
            border-radius: 15px;
            padding: 25px;
            backdrop-filter: blur(10px);
        }
        .settings-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
        }
        .setting-item {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .setting-label {
            font-weight: 600;
            font-size: 0.9rem;
        }
        select, input[type="range"] {
            padding: 10px;
            border-radius: 6px;
            border: none;
            font-size: 1rem;
        }
        select {
            background: rgba(255,255,255,0.9);
            color: #1e3c72;
        }
        .range-value {
            font-size: 1.2rem;
            font-weight: bold;
            color: #00d4ff;
        }
        .instructions {
            background: rgba(255,255,255,0.1);
            border-radius: 10px;
            padding: 20px;
            margin-top: 20px;
        }
        .instructions h3 {
            margin-bottom: 15px;
            color: #00d4ff;
        }
        .instructions ul {
            padding-left: 20px;
            line-height: 1.8;
        }
        @media (max-width: 768px) {
            h1 { font-size: 1.5rem; }
            .game-state h2 { font-size: 1.8rem; }
            .sequence-display { font-size: 1.5rem; }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>üß† Memory Chain Game</h1>
            <p>Progressive memory training with morse code sequences</p>
            <div class="status-bar">
                <div class="status-item">
                    <span id="connectionStatus" class="status-disconnected">‚óè Disconnected</span>
                </div>
                <div class="status-item">
                    Score: <span id="currentScore">0</span>
                </div>
                <div class="status-item">
                    High: <span id="highScore">0</span>
                </div>
            </div>
        </header>

        <div class="game-container">
            <div class="game-state">
                <h2 id="gameStateText" class="state-ready">READY</h2>
                <p id="gameStateDesc">Press Start to begin your memory training</p>
            </div>

            <div class="sequence-display" id="sequenceDisplay">
                ---
            </div>

            <div class="controls">
                <button id="startBtn" class="btn-primary" onclick="startGame()">Start Game</button>
                <button id="settingsBtn" class="btn-secondary" onclick="toggleSettings()">Settings</button>
                <button id="backBtn" class="btn-secondary" onclick="goBack()">Back to Dashboard</button>
            </div>
        </div>

        <div class="settings-panel" id="settingsPanel" style="display: none;">
            <h2 style="margin-bottom: 20px;">Game Settings</h2>
            <div class="settings-grid">
                <div class="setting-item">
                    <label class="setting-label">Difficulty</label>
                    <select id="difficulty">
                        <option value="0">Beginner (Letters Only)</option>
                        <option value="1">Intermediate (+ Numbers)</option>
                        <option value="2">Advanced (+ Prosigns)</option>
                    </select>
                </div>
                <div class="setting-item">
                    <label class="setting-label">Game Mode</label>
                    <select id="gameMode">
                        <option value="0">Standard (One Life)</option>
                        <option value="1">Practice (3 Lives)</option>
                        <option value="2">Timed (60 Seconds)</option>
                    </select>
                </div>
                <div class="setting-item">
                    <label class="setting-label">Speed: <span class="range-value" id="wpmValue">15</span> WPM</label>
                    <input type="range" id="wpm" min="5" max="40" value="15" oninput="updateWpmDisplay()">
                </div>
                <div class="setting-item">
                    <label class="setting-label">Sound</label>
                    <select id="sound">
                        <option value="true">Enabled</option>
                        <option value="false">Silent</option>
                    </select>
                </div>
                <div class="setting-item">
                    <label class="setting-label">Show Sequence</label>
                    <select id="hints">
                        <option value="false">Hidden (True Memory)</option>
                        <option value="true">Visible (Training)</option>
                    </select>
                </div>
            </div>
            <div style="margin-top: 20px; text-align: center;">
                <button class="btn-primary" onclick="saveSettings()">Save Settings</button>
            </div>
        </div>

        <div class="instructions">
            <h3>How to Play</h3>
            <ul>
                <li><strong>Listen:</strong> The device plays a morse code sequence</li>
                <li><strong>Remember:</strong> Memorize the characters you heard</li>
                <li><strong>Reproduce:</strong> Key the same sequence using your paddle</li>
                <li><strong>Advance:</strong> Each correct round adds one more character</li>
                <li><strong>Challenge:</strong> How long can you make the chain?</li>
            </ul>
            <p style="margin-top: 15px; opacity: 0.8;">
                Use Left Ctrl = Dit, Right Ctrl = Dah (or connect your Vail adapter)
            </p>
        </div>
    </div>

    <script>
        let ws = null;
        let gameActive = false;
        let currentState = 'ready';
        let audioContext = null;
        let oscillator = null;
        let timedModeInterval = null;

        // Morse code lookup table
        const MORSE_TABLE = {
            'A': '.-', 'B': '-...', 'C': '-.-.', 'D': '-..', 'E': '.', 'F': '..-.',
            'G': '--.', 'H': '....', 'I': '..', 'J': '.---', 'K': '-.-', 'L': '.-..',
            'M': '--', 'N': '-.', 'O': '---', 'P': '.--.', 'Q': '--.-', 'R': '.-.',
            'S': '...', 'T': '-', 'U': '..-', 'V': '...-', 'W': '.--', 'X': '-..-',
            'Y': '-.--', 'Z': '--..',
            '0': '-----', '1': '.----', '2': '..---', '3': '...--', '4': '....-',
            '5': '.....', '6': '-....', '7': '--...', '8': '---..', '9': '----.'
        };

        function getMorsePattern(text) {
            return text.split('').map(c => MORSE_TABLE[c.toUpperCase()] || '').filter(p => p).join(' ');
        }

        // Character sets by difficulty
        const CHARSET_BEGINNER = 'ETIANMSURWDKGOHVFLPJBXCYZQ';
        const CHARSET_INTERMEDIATE = 'ETIANMSURWDKGOHVFLPJBXCYZQ0123456789';
        const CHARSET_ADVANCED = 'ETIANMSURWDKGOHVFLPJBXCYZQ0123456789';

        // Browser-side game state
        let gameState = {
            sequence: '',
            playerPosition: 0,
            currentScore: 0,
            highScore: 0,
            lives: 1,
            difficulty: 0,
            mode: 0,      // 0=Standard, 1=Practice(3 lives), 2=Timed
            wpm: 15,
            soundEnabled: true,
            showHints: false,
            gameStartTime: 0,
            playingSequence: false,
            waitingForPlayer: false
        };

        // Initialize Web Audio API
        function initAudio() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
        }

        // Play morse code tone
        function playTone(frequency, duration) {
            return new Promise((resolve) => {
                const osc = audioContext.createOscillator();
                const gainNode = audioContext.createGain();

                osc.type = 'sine';
                osc.frequency.value = frequency;

                gainNode.gain.value = 0.3;  // Volume

                osc.connect(gainNode);
                gainNode.connect(audioContext.destination);

                osc.start(audioContext.currentTime);
                osc.stop(audioContext.currentTime + duration / 1000);

                setTimeout(resolve, duration);
            });
        }

        // Play morse code pattern
        async function playMorsePattern(patterns, wpm, soundEnabled) {
            if (!soundEnabled) {
                console.log('Sound disabled, skipping playback');
                return;
            }

            initAudio();

            // Calculate timing (PARIS standard)
            const ditDuration = 1200 / wpm;  // milliseconds
            const dahDuration = ditDuration * 3;
            const frequency = 700;  // Hz

            const chars = patterns.split(' ');  // Split by spaces (character boundaries)

            for (let i = 0; i < chars.length; i++) {
                const pattern = chars[i];

                // Play each dit/dah in the pattern
                for (let j = 0; j < pattern.length; j++) {
                    if (pattern[j] === '.') {
                        await playTone(frequency, ditDuration);
                    } else if (pattern[j] === '-') {
                        await playTone(frequency, dahDuration);
                    }

                    // Inter-element gap (between dits/dahs within a character)
                    if (j < pattern.length - 1) {
                        await new Promise(resolve => setTimeout(resolve, ditDuration));
                    }
                }

                // Letter gap (between characters)
                if (i < chars.length - 1) {
                    await new Promise(resolve => setTimeout(resolve, ditDuration * 3));
                }
            }
        }

        // Game logic functions
        function getCharset() {
            switch (gameState.difficulty) {
                case 1: return CHARSET_INTERMEDIATE;
                case 2: return CHARSET_ADVANCED;
                default: return CHARSET_BEGINNER;
            }
        }

        function generateNextChar() {
            const charset = getCharset();
            return charset[Math.floor(Math.random() * charset.length)];
        }

        async function startNewRound() {
            // Add one character to sequence
            gameState.sequence += generateNextChar();
            gameState.playerPosition = 0;
            gameState.playingSequence = true;
            gameState.waitingForPlayer = false;

            // Update UI
            updateGameState('playing', 'Listen carefully...');
            updateSequence(gameState.sequence, gameState.showHints);
            updateScoreDisplay();

            // Play the sequence as morse
            const morsePattern = getMorsePattern(gameState.sequence);
            if (gameState.soundEnabled) {
                await playMorsePattern(morsePattern, gameState.wpm, true);
            }

            // Now it's the player's turn
            gameState.playingSequence = false;
            gameState.waitingForPlayer = true;
            updateGameState('listening', 'Your turn! Reproduce the sequence');
        }

        function handleDecodedChar(decodedChar) {
            if (!gameState.waitingForPlayer) return;

            const expected = gameState.sequence[gameState.playerPosition];

            if (decodedChar.toUpperCase() === expected) {
                gameState.playerPosition++;

                if (gameState.playerPosition >= gameState.sequence.length) {
                    // Round complete!
                    gameState.currentScore = gameState.sequence.length;
                    if (gameState.currentScore > gameState.highScore) {
                        gameState.highScore = gameState.currentScore;
                    }

                    showFeedback(true);
                    updateScoreDisplay();

                    // Start next round after delay
                    setTimeout(() => {
                        if (gameActive) startNewRound();
                    }, 1500);
                }
            } else {
                // Wrong character
                showFeedback(false);

                if (gameState.mode === 1) {
                    // Practice mode - lose a life
                    gameState.lives--;
                    if (gameState.lives > 0) {
                        gameState.playerPosition = 0;
                        setTimeout(() => {
                            updateGameState('listening', `Wrong! ${gameState.lives} lives left. Try again`);
                            gameState.waitingForPlayer = true;
                        }, 1500);
                    } else {
                        endGame('Out of lives');
                    }
                } else {
                    // Standard mode - game over
                    endGame('Wrong character');
                }
            }
        }

        function endGame(reason) {
            gameActive = false;
            gameState.waitingForPlayer = false;
            if (timedModeInterval) {
                clearInterval(timedModeInterval);
                timedModeInterval = null;
            }
            handleGameOver(gameState.currentScore, reason);
        }

        function updateScoreDisplay() {
            document.getElementById('currentScore').textContent = gameState.currentScore;
            document.getElementById('highScore').textContent = gameState.highScore;
        }

        // Initialize page
        loadSettings();

        // Start game
        async function startGame() {
            try {
                const difficulty = parseInt(document.getElementById('difficulty').value);
                const mode = parseInt(document.getElementById('gameMode').value);
                const wpm = parseInt(document.getElementById('wpm').value);
                const sound = document.getElementById('sound').value === 'true';
                const hints = document.getElementById('hints').value === 'true';

                // Initialize game state
                gameState = {
                    sequence: '',
                    playerPosition: 0,
                    currentScore: 0,
                    highScore: gameState.highScore, // Preserve high score across games
                    lives: mode === 1 ? 3 : 1,
                    difficulty, mode, wpm,
                    soundEnabled: sound,
                    showHints: hints,
                    gameStartTime: Date.now(),
                    playingSequence: false,
                    waitingForPlayer: false
                };

                // Tell device to enter web mode
                const response = await fetch('/api/memory-chain/start', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({ difficulty, mode, wpm, sound, hints })
                });

                if (!response.ok) throw new Error('Failed to start game');

                // Connect WebSocket (for decoded characters from device)
                const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
                const wsUrl = `${protocol}//${window.location.host}/ws/memory-chain`;
                ws = new WebSocket(wsUrl);

                ws.onopen = () => {
                    document.getElementById('connectionStatus').textContent = '‚óè Connected';
                    document.getElementById('connectionStatus').className = 'status-connected';
                    document.getElementById('startBtn').disabled = true;
                    gameActive = true;

                    // Start timed mode timer if applicable
                    if (gameState.mode === 2) {
                        timedModeInterval = setInterval(() => {
                            const elapsed = (Date.now() - gameState.gameStartTime) / 1000;
                            if (elapsed >= 60) {
                                clearInterval(timedModeInterval);
                                timedModeInterval = null;
                                endGame("Time's up!");
                            }
                        }, 1000);
                    }

                    // Start first round after brief delay
                    setTimeout(() => startNewRound(), 500);
                };

                ws.onmessage = (event) => {
                    const msg = JSON.parse(event.data);
                    if (msg.type === 'decoded' && msg.char) {
                        handleDecodedChar(msg.char);
                    }
                };

                ws.onclose = () => {
                    document.getElementById('connectionStatus').textContent = '‚óè Disconnected';
                    document.getElementById('connectionStatus').className = 'status-disconnected';
                    document.getElementById('startBtn').disabled = false;
                    if (gameActive) endGame('Connection lost');
                };

                ws.onerror = (error) => {
                    console.error('WebSocket error:', error);
                    alert('Connection error. Please try again.');
                };

            } catch (error) {
                console.error('Failed to start game:', error);
                alert('Failed to start game. Make sure device is connected.');
            }
        }

        // Update game state display
        function updateGameState(state, description) {
            currentState = state;
            const stateText = document.getElementById('gameStateText');
            const stateDesc = document.getElementById('gameStateDesc');

            stateText.className = 'state-' + state;
            stateDesc.textContent = description;

            const stateNames = {
                'ready': 'READY',
                'playing': 'LISTEN',
                'listening': 'YOUR TURN',
                'feedback': 'FEEDBACK',
                'game_over': 'GAME OVER'
            };

            stateText.textContent = stateNames[state] || state.toUpperCase();

            // Start/stop silence timer based on state
            if (state === 'listening') {
                // Reset timing state for new round
                lastKeyUpTime = 0;
                keyDownTime = {};
                anyKeyDown = false;
                startSilenceTimer();
            } else {
                stopSilenceTimer();
            }
        }

        // Update sequence display
        function updateSequence(characters, show) {
            const display = document.getElementById('sequenceDisplay');
            if (show) {
                display.textContent = characters;
            } else {
                display.textContent = '?'.repeat(characters.length);
            }
        }

        // Show correct/wrong feedback
        function showFeedback(correct) {
            const stateText = document.getElementById('gameStateText');
            if (correct) {
                stateText.textContent = '‚úì CORRECT!';
                stateText.className = 'state-correct';
            } else {
                stateText.textContent = '‚úó WRONG';
                stateText.className = 'state-wrong';
            }
        }

        // Handle game over
        function handleGameOver(finalScore, reason) {
            updateGameState('game_over', `Final score: ${finalScore} - ${reason}`);
            document.getElementById('startBtn').disabled = false;
            gameActive = false;
            if (ws) {
                ws.close();
                ws = null;
            }
        }

        // Keyboard input for morse code
        let keyDownTime = {};
        let lastKeyUpTime = 0;
        let anyKeyDown = false;
        let silenceTimer = null;

        // Send silence updates periodically when no keys are pressed
        // Only sends after user has started keying (lastKeyUpTime is set)
        function sendSilenceUpdate() {
            if (!gameActive || currentState !== 'listening' || anyKeyDown) return;

            // Don't send silence until user has keyed at least once
            if (lastKeyUpTime === 0) return;

            const now = performance.now();
            const silenceDuration = now - lastKeyUpTime;
            if (ws && silenceDuration > 50) {  // Meaningful silence
                console.log('Sending ongoing silence:', silenceDuration, 'ms');
                ws.send(JSON.stringify({
                    type: 'timing',
                    duration: silenceDuration,
                    positive: false
                }));
                lastKeyUpTime = now;  // Reset for next update
            }
        }

        // Start silence timer when entering listening state
        function startSilenceTimer() {
            if (silenceTimer) clearInterval(silenceTimer);
            silenceTimer = setInterval(sendSilenceUpdate, 100);  // Check every 100ms
        }

        // Stop silence timer when leaving listening state
        function stopSilenceTimer() {
            if (silenceTimer) {
                clearInterval(silenceTimer);
                silenceTimer = null;
            }
        }

        document.addEventListener('keydown', (e) => {
            if (!gameActive || currentState !== 'listening') return;
            if (e.repeat) return;

            let key = null;
            if (e.code === 'ControlLeft') key = 'dit';
            if (e.code === 'ControlRight') key = 'dah';

            if (key && !keyDownTime[key]) {
                const now = performance.now();
                console.log('Key down:', key);

                // Send silence timing if there was a gap since last key-up
                if (lastKeyUpTime > 0 && !anyKeyDown) {
                    const silenceDuration = now - lastKeyUpTime;
                    if (ws && silenceDuration > 10) {  // Only send meaningful gaps
                        console.log('Sending silence timing:', silenceDuration, 'ms');
                        ws.send(JSON.stringify({
                            type: 'timing',
                            duration: silenceDuration,
                            positive: false
                        }));
                    }
                }

                keyDownTime[key] = now;
                anyKeyDown = true;
            }
        });

        document.addEventListener('keyup', (e) => {
            if (!gameActive || currentState !== 'listening') return;

            let key = null;
            if (e.code === 'ControlLeft') key = 'dit';
            if (e.code === 'ControlRight') key = 'dah';

            if (key && keyDownTime[key] && ws) {
                const now = performance.now();
                const duration = now - keyDownTime[key];

                console.log('Key up:', key, 'duration:', duration, 'ms');

                // Send positive timing (key-down duration)
                ws.send(JSON.stringify({
                    type: 'timing',
                    duration: duration,
                    positive: true
                }));

                delete keyDownTime[key];
                lastKeyUpTime = now;

                // Check if all keys are up
                anyKeyDown = Object.keys(keyDownTime).length > 0;
            }
        });

        // Settings functions
        function toggleSettings() {
            const panel = document.getElementById('settingsPanel');
            panel.style.display = panel.style.display === 'none' ? 'block' : 'none';
        }

        function updateWpmDisplay() {
            document.getElementById('wpmValue').textContent = document.getElementById('wpm').value;
        }

        function loadSettings() {
            const settings = JSON.parse(localStorage.getItem('memoryChainSettings') || '{}');
            if (settings.difficulty !== undefined) document.getElementById('difficulty').value = settings.difficulty;
            if (settings.mode !== undefined) document.getElementById('gameMode').value = settings.mode;
            if (settings.wpm !== undefined) {
                document.getElementById('wpm').value = settings.wpm;
                updateWpmDisplay();
            }
            if (settings.sound !== undefined) document.getElementById('sound').value = settings.sound;
            if (settings.hints !== undefined) document.getElementById('hints').value = settings.hints;
        }

        function saveSettings() {
            const settings = {
                difficulty: document.getElementById('difficulty').value,
                mode: document.getElementById('gameMode').value,
                wpm: document.getElementById('wpm').value,
                sound: document.getElementById('sound').value,
                hints: document.getElementById('hints').value
            };
            localStorage.setItem('memoryChainSettings', JSON.stringify(settings));
            alert('Settings saved!');
            toggleSettings();
        }

        function goBack() {
            if (timedModeInterval) {
                clearInterval(timedModeInterval);
                timedModeInterval = null;
            }
            if (gameActive && ws) {
                ws.close();
            }
            window.location.href = '/';
        }
    </script>
</body>
</html>
