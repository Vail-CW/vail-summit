<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Memory Chain - VAIL SUMMIT</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Arial, sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            color: #fff;
            padding: 20px;
            min-height: 100vh;
        }
        .container { max-width: 900px; margin: 0 auto; }
        header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            background: rgba(255,255,255,0.1);
            border-radius: 15px;
            backdrop-filter: blur(10px);
        }
        h1 { font-size: 2rem; margin-bottom: 10px; }
        .status-bar {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 15px;
            flex-wrap: wrap;
        }
        .status-item {
            background: rgba(255,255,255,0.15);
            padding: 8px 16px;
            border-radius: 8px;
            font-size: 0.9rem;
        }
        .status-connected { color: #4ade80; }
        .status-disconnected { color: #f87171; }
        .game-container {
            background: rgba(255,255,255,0.1);
            border-radius: 15px;
            padding: 30px;
            backdrop-filter: blur(10px);
            margin-bottom: 20px;
        }
        .game-state {
            text-align: center;
            margin-bottom: 30px;
        }
        .game-state h2 {
            font-size: 2.5rem;
            margin-bottom: 10px;
        }
        .state-ready { color: #60a5fa; }
        .state-playing { color: #fbbf24; }
        .state-listening { color: #4ade80; }
        .state-correct { color: #10b981; }
        .state-wrong { color: #ef4444; }
        .game-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-bottom: 30px;
        }
        .stat-card {
            background: rgba(255,255,255,0.1);
            padding: 20px;
            border-radius: 10px;
            text-align: center;
        }
        .stat-value {
            font-size: 2.5rem;
            font-weight: bold;
            margin-bottom: 5px;
        }
        .stat-label {
            font-size: 0.9rem;
            opacity: 0.8;
        }
        .sequence-display {
            background: rgba(0,0,0,0.3);
            border-radius: 10px;
            padding: 25px;
            text-align: center;
            min-height: 100px;
            margin-bottom: 25px;
            font-size: 2rem;
            font-family: monospace;
            letter-spacing: 8px;
        }
        .controls {
            display: flex;
            gap: 15px;
            justify-content: center;
            flex-wrap: wrap;
        }
        button {
            padding: 15px 30px;
            font-size: 1.1rem;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.2s;
        }
        .btn-primary {
            background: #00d4ff;
            color: #1e3c72;
        }
        .btn-primary:hover { background: #00b8e6; }
        .btn-secondary {
            background: rgba(255,255,255,0.2);
            color: #fff;
        }
        .btn-secondary:hover { background: rgba(255,255,255,0.3); }
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .settings-panel {
            background: rgba(255,255,255,0.1);
            border-radius: 15px;
            padding: 25px;
            backdrop-filter: blur(10px);
        }
        .settings-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
        }
        .setting-item {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .setting-label {
            font-weight: 600;
            font-size: 0.9rem;
        }
        select, input[type="range"] {
            padding: 10px;
            border-radius: 6px;
            border: none;
            font-size: 1rem;
        }
        select {
            background: rgba(255,255,255,0.9);
            color: #1e3c72;
        }
        .range-value {
            font-size: 1.2rem;
            font-weight: bold;
            color: #00d4ff;
        }
        .instructions {
            background: rgba(255,255,255,0.1);
            border-radius: 10px;
            padding: 20px;
            margin-top: 20px;
        }
        .instructions h3 {
            margin-bottom: 15px;
            color: #00d4ff;
        }
        .instructions ul {
            padding-left: 20px;
            line-height: 1.8;
        }
        @media (max-width: 768px) {
            h1 { font-size: 1.5rem; }
            .game-state h2 { font-size: 1.8rem; }
            .sequence-display { font-size: 1.5rem; }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>üß† Memory Chain Game</h1>
            <p>Progressive memory training with morse code sequences</p>
            <div class="status-bar">
                <div class="status-item">
                    <span id="connectionStatus" class="status-disconnected">‚óè Disconnected</span>
                </div>
                <div class="status-item">
                    Score: <span id="currentScore">0</span>
                </div>
                <div class="status-item">
                    High: <span id="highScore">0</span>
                </div>
            </div>
        </header>

        <div class="game-container">
            <div class="game-state">
                <h2 id="gameStateText" class="state-ready">READY</h2>
                <p id="gameStateDesc">Press Start to begin your memory training</p>
            </div>

            <div class="sequence-display" id="sequenceDisplay">
                ---
            </div>

            <div class="controls">
                <button id="startBtn" class="btn-primary" onclick="startGame()">Start Game</button>
                <button id="settingsBtn" class="btn-secondary" onclick="toggleSettings()">Settings</button>
                <button id="backBtn" class="btn-secondary" onclick="goBack()">Back to Dashboard</button>
            </div>
        </div>

        <div class="settings-panel" id="settingsPanel" style="display: none;">
            <h2 style="margin-bottom: 20px;">Game Settings</h2>
            <div class="settings-grid">
                <div class="setting-item">
                    <label class="setting-label">Difficulty</label>
                    <select id="difficulty">
                        <option value="0">Beginner (Letters Only)</option>
                        <option value="1">Intermediate (+ Numbers)</option>
                        <option value="2">Advanced (+ Prosigns)</option>
                    </select>
                </div>
                <div class="setting-item">
                    <label class="setting-label">Game Mode</label>
                    <select id="gameMode">
                        <option value="0">Standard (One Life)</option>
                        <option value="1">Practice (3 Lives)</option>
                        <option value="2">Timed (60 Seconds)</option>
                    </select>
                </div>
                <div class="setting-item">
                    <label class="setting-label">Speed: <span class="range-value" id="wpmValue">15</span> WPM</label>
                    <input type="range" id="wpm" min="5" max="40" value="15" oninput="updateWpmDisplay()">
                </div>
                <div class="setting-item">
                    <label class="setting-label">Sound</label>
                    <select id="sound">
                        <option value="true">Enabled</option>
                        <option value="false">Silent</option>
                    </select>
                </div>
                <div class="setting-item">
                    <label class="setting-label">Show Sequence</label>
                    <select id="hints">
                        <option value="false">Hidden (True Memory)</option>
                        <option value="true">Visible (Training)</option>
                    </select>
                </div>
            </div>
            <div style="margin-top: 20px; text-align: center;">
                <button class="btn-primary" onclick="saveSettings()">Save Settings</button>
            </div>
        </div>

        <div class="instructions">
            <h3>How to Play</h3>
            <ul>
                <li><strong>Listen:</strong> The device plays a morse code sequence</li>
                <li><strong>Remember:</strong> Memorize the characters you heard</li>
                <li><strong>Reproduce:</strong> Key the same sequence using your paddle</li>
                <li><strong>Advance:</strong> Each correct round adds one more character</li>
                <li><strong>Challenge:</strong> How long can you make the chain?</li>
            </ul>
            <p style="margin-top: 15px; opacity: 0.8;">
                Use Left Ctrl = Dit, Right Ctrl = Dah (or connect your Vail adapter)
            </p>
        </div>
    </div>

    <script>
        let ws = null;
        let gameActive = false;
        let currentState = 'ready';
        let audioContext = null;
        let oscillator = null;

        // Initialize Web Audio API
        function initAudio() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
        }

        // Play morse code tone
        function playTone(frequency, duration) {
            return new Promise((resolve) => {
                const osc = audioContext.createOscillator();
                const gainNode = audioContext.createGain();

                osc.type = 'sine';
                osc.frequency.value = frequency;

                gainNode.gain.value = 0.3;  // Volume

                osc.connect(gainNode);
                gainNode.connect(audioContext.destination);

                osc.start(audioContext.currentTime);
                osc.stop(audioContext.currentTime + duration / 1000);

                setTimeout(resolve, duration);
            });
        }

        // Play morse code pattern
        async function playMorsePattern(patterns, wpm, soundEnabled) {
            if (!soundEnabled) {
                console.log('Sound disabled, skipping playback');
                return;
            }

            initAudio();

            // Calculate timing (PARIS standard)
            const ditDuration = 1200 / wpm;  // milliseconds
            const dahDuration = ditDuration * 3;
            const frequency = 700;  // Hz

            const chars = patterns.split(' ');  // Split by spaces (character boundaries)

            for (let i = 0; i < chars.length; i++) {
                const pattern = chars[i];

                // Play each dit/dah in the pattern
                for (let j = 0; j < pattern.length; j++) {
                    if (pattern[j] === '.') {
                        await playTone(frequency, ditDuration);
                    } else if (pattern[j] === '-') {
                        await playTone(frequency, dahDuration);
                    }

                    // Inter-element gap (between dits/dahs within a character)
                    if (j < pattern.length - 1) {
                        await new Promise(resolve => setTimeout(resolve, ditDuration));
                    }
                }

                // Letter gap (between characters)
                if (i < chars.length - 1) {
                    await new Promise(resolve => setTimeout(resolve, ditDuration * 3));
                }
            }
        }

        // Initialize page
        loadSettings();

        // Start game
        async function startGame() {
            try {
                // Request device to enter Memory Chain mode
                const response = await fetch('/api/memory-chain/start', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        difficulty: parseInt(document.getElementById('difficulty').value),
                        mode: parseInt(document.getElementById('gameMode').value),
                        wpm: parseInt(document.getElementById('wpm').value),
                        sound: document.getElementById('sound').value === 'true',
                        hints: document.getElementById('hints').value === 'true'
                    })
                });

                if (!response.ok) throw new Error('Failed to start game');

                const data = await response.json();
                console.log('Game start response:', data);

                // Connect WebSocket using current host (works with both IP and mDNS)
                const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
                const wsUrl = `${protocol}//${window.location.host}/ws/memory-chain`;
                console.log('Connecting to WebSocket:', wsUrl);
                ws = new WebSocket(wsUrl);

                ws.onopen = () => {
                    console.log('WebSocket connected');
                    document.getElementById('connectionStatus').textContent = '‚óè Connected';
                    document.getElementById('connectionStatus').className = 'status-connected';
                    document.getElementById('startBtn').disabled = true;
                    gameActive = true;
                };

                ws.onmessage = (event) => {
                    console.log('WebSocket message received:', event.data);
                    const msg = JSON.parse(event.data);
                    handleGameMessage(msg);
                };

                ws.onclose = () => {
                    document.getElementById('connectionStatus').textContent = '‚óè Disconnected';
                    document.getElementById('connectionStatus').className = 'status-disconnected';
                    document.getElementById('startBtn').disabled = false;
                    gameActive = false;
                };

                ws.onerror = (error) => {
                    console.error('WebSocket error:', error);
                    alert('Connection error. Please try again.');
                };

            } catch (error) {
                console.error('Failed to start game:', error);
                alert('Failed to start game. Make sure device is connected.');
            }
        }

        // Handle game state messages from device
        function handleGameMessage(msg) {
            console.log('Handling message type:', msg.type, msg);
            switch (msg.type) {
                case 'state':
                    updateGameState(msg.state, msg.description);
                    break;
                case 'sequence':
                    updateSequence(msg.characters, msg.show);
                    break;
                case 'play_morse':
                    // Play morse code audio in browser
                    console.log('Playing morse pattern:', msg.patterns, 'at', msg.wpm, 'WPM');
                    playMorsePattern(msg.patterns, msg.wpm, msg.soundEnabled);
                    break;
                case 'score':
                    document.getElementById('currentScore').textContent = msg.current;
                    document.getElementById('highScore').textContent = msg.high;
                    break;
                case 'feedback':
                    showFeedback(msg.correct);
                    break;
                case 'game_over':
                    handleGameOver(msg.finalScore, msg.reason);
                    break;
            }
        }

        // Update game state display
        function updateGameState(state, description) {
            currentState = state;
            const stateText = document.getElementById('gameStateText');
            const stateDesc = document.getElementById('gameStateDesc');

            stateText.className = 'state-' + state;
            stateDesc.textContent = description;

            const stateNames = {
                'ready': 'READY',
                'playing': 'LISTEN',
                'listening': 'YOUR TURN',
                'feedback': 'FEEDBACK',
                'game_over': 'GAME OVER'
            };

            stateText.textContent = stateNames[state] || state.toUpperCase();

            // Start/stop silence timer based on state
            if (state === 'listening') {
                // Reset timing state for new round
                lastKeyUpTime = 0;
                keyDownTime = {};
                anyKeyDown = false;
                startSilenceTimer();
            } else {
                stopSilenceTimer();
            }
        }

        // Update sequence display
        function updateSequence(characters, show) {
            const display = document.getElementById('sequenceDisplay');
            if (show) {
                display.textContent = characters;
            } else {
                display.textContent = '?'.repeat(characters.length);
            }
        }

        // Show correct/wrong feedback
        function showFeedback(correct) {
            const stateText = document.getElementById('gameStateText');
            if (correct) {
                stateText.textContent = '‚úì CORRECT!';
                stateText.className = 'state-correct';
            } else {
                stateText.textContent = '‚úó WRONG';
                stateText.className = 'state-wrong';
            }
        }

        // Handle game over
        function handleGameOver(finalScore, reason) {
            updateGameState('game_over', `Final score: ${finalScore} - ${reason}`);
            document.getElementById('startBtn').disabled = false;
            gameActive = false;
            if (ws) {
                ws.close();
                ws = null;
            }
        }

        // Keyboard input for morse code
        let keyDownTime = {};
        let lastKeyUpTime = 0;
        let anyKeyDown = false;
        let silenceTimer = null;

        // Send silence updates periodically when no keys are pressed
        // Only sends after user has started keying (lastKeyUpTime is set)
        function sendSilenceUpdate() {
            if (!gameActive || currentState !== 'listening' || anyKeyDown) return;

            // Don't send silence until user has keyed at least once
            if (lastKeyUpTime === 0) return;

            const now = performance.now();
            const silenceDuration = now - lastKeyUpTime;
            if (ws && silenceDuration > 50) {  // Meaningful silence
                console.log('Sending ongoing silence:', silenceDuration, 'ms');
                ws.send(JSON.stringify({
                    type: 'timing',
                    duration: silenceDuration,
                    positive: false
                }));
                lastKeyUpTime = now;  // Reset for next update
            }
        }

        // Start silence timer when entering listening state
        function startSilenceTimer() {
            if (silenceTimer) clearInterval(silenceTimer);
            silenceTimer = setInterval(sendSilenceUpdate, 100);  // Check every 100ms
        }

        // Stop silence timer when leaving listening state
        function stopSilenceTimer() {
            if (silenceTimer) {
                clearInterval(silenceTimer);
                silenceTimer = null;
            }
        }

        document.addEventListener('keydown', (e) => {
            if (!gameActive || currentState !== 'listening') return;
            if (e.repeat) return;

            let key = null;
            if (e.code === 'ControlLeft') key = 'dit';
            if (e.code === 'ControlRight') key = 'dah';

            if (key && !keyDownTime[key]) {
                const now = performance.now();
                console.log('Key down:', key);

                // Send silence timing if there was a gap since last key-up
                if (lastKeyUpTime > 0 && !anyKeyDown) {
                    const silenceDuration = now - lastKeyUpTime;
                    if (ws && silenceDuration > 10) {  // Only send meaningful gaps
                        console.log('Sending silence timing:', silenceDuration, 'ms');
                        ws.send(JSON.stringify({
                            type: 'timing',
                            duration: silenceDuration,
                            positive: false
                        }));
                    }
                }

                keyDownTime[key] = now;
                anyKeyDown = true;
            }
        });

        document.addEventListener('keyup', (e) => {
            if (!gameActive || currentState !== 'listening') return;

            let key = null;
            if (e.code === 'ControlLeft') key = 'dit';
            if (e.code === 'ControlRight') key = 'dah';

            if (key && keyDownTime[key] && ws) {
                const now = performance.now();
                const duration = now - keyDownTime[key];

                console.log('Key up:', key, 'duration:', duration, 'ms');

                // Send positive timing (key-down duration)
                ws.send(JSON.stringify({
                    type: 'timing',
                    duration: duration,
                    positive: true
                }));

                delete keyDownTime[key];
                lastKeyUpTime = now;

                // Check if all keys are up
                anyKeyDown = Object.keys(keyDownTime).length > 0;
            }
        });

        // Settings functions
        function toggleSettings() {
            const panel = document.getElementById('settingsPanel');
            panel.style.display = panel.style.display === 'none' ? 'block' : 'none';
        }

        function updateWpmDisplay() {
            document.getElementById('wpmValue').textContent = document.getElementById('wpm').value;
        }

        function loadSettings() {
            const settings = JSON.parse(localStorage.getItem('memoryChainSettings') || '{}');
            if (settings.difficulty !== undefined) document.getElementById('difficulty').value = settings.difficulty;
            if (settings.mode !== undefined) document.getElementById('gameMode').value = settings.mode;
            if (settings.wpm !== undefined) {
                document.getElementById('wpm').value = settings.wpm;
                updateWpmDisplay();
            }
            if (settings.sound !== undefined) document.getElementById('sound').value = settings.sound;
            if (settings.hints !== undefined) document.getElementById('hints').value = settings.hints;
        }

        function saveSettings() {
            const settings = {
                difficulty: document.getElementById('difficulty').value,
                mode: document.getElementById('gameMode').value,
                wpm: document.getElementById('wpm').value,
                sound: document.getElementById('sound').value,
                hints: document.getElementById('hints').value
            };
            localStorage.setItem('memoryChainSettings', JSON.stringify(settings));
            alert('Settings saved!');
            toggleSettings();
        }

        function goBack() {
            if (gameActive && ws) {
                ws.close();
            }
            window.location.href = '/';
        }
    </script>
</body>
</html>
